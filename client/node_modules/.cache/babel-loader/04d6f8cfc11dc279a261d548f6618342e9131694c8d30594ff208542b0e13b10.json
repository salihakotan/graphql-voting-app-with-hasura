{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SubscriptionClient = void 0;\nvar _global = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : {};\nvar NativeWebSocket = _global.WebSocket || _global.MozWebSocket;\nvar Backoff = require(\"backo2\");\nvar eventemitter3_1 = require(\"eventemitter3\");\nvar is_string_1 = require(\"./utils/is-string\");\nvar is_object_1 = require(\"./utils/is-object\");\nvar printer_1 = require(\"graphql/language/printer\");\nvar getOperationAST_1 = require(\"graphql/utilities/getOperationAST\");\nvar symbol_observable_1 = require(\"symbol-observable\");\nvar protocol_1 = require(\"./protocol\");\nvar defaults_1 = require(\"./defaults\");\nvar message_types_1 = require(\"./message-types\");\nvar SubscriptionClient = function () {\n  function SubscriptionClient(url, options, webSocketImpl, webSocketProtocols) {\n    var _a = options || {},\n      _b = _a.connectionCallback,\n      connectionCallback = _b === void 0 ? undefined : _b,\n      _c = _a.connectionParams,\n      connectionParams = _c === void 0 ? {} : _c,\n      _d = _a.minTimeout,\n      minTimeout = _d === void 0 ? defaults_1.MIN_WS_TIMEOUT : _d,\n      _e = _a.timeout,\n      timeout = _e === void 0 ? defaults_1.WS_TIMEOUT : _e,\n      _f = _a.reconnect,\n      reconnect = _f === void 0 ? false : _f,\n      _g = _a.reconnectionAttempts,\n      reconnectionAttempts = _g === void 0 ? Infinity : _g,\n      _h = _a.lazy,\n      lazy = _h === void 0 ? false : _h,\n      _j = _a.inactivityTimeout,\n      inactivityTimeout = _j === void 0 ? 0 : _j,\n      _k = _a.wsOptionArguments,\n      wsOptionArguments = _k === void 0 ? [] : _k;\n    this.wsImpl = webSocketImpl || NativeWebSocket;\n    if (!this.wsImpl) {\n      throw new Error('Unable to find native implementation, or alternative implementation for WebSocket!');\n    }\n    this.wsProtocols = webSocketProtocols || protocol_1.GRAPHQL_WS;\n    this.connectionCallback = connectionCallback;\n    this.url = url;\n    this.operations = {};\n    this.nextOperationId = 0;\n    this.minWsTimeout = minTimeout;\n    this.wsTimeout = timeout;\n    this.unsentMessagesQueue = [];\n    this.reconnect = reconnect;\n    this.reconnecting = false;\n    this.reconnectionAttempts = reconnectionAttempts;\n    this.lazy = !!lazy;\n    this.inactivityTimeout = inactivityTimeout;\n    this.closedByUser = false;\n    this.backoff = new Backoff({\n      jitter: 0.5\n    });\n    this.eventEmitter = new eventemitter3_1.EventEmitter();\n    this.middlewares = [];\n    this.client = null;\n    this.maxConnectTimeGenerator = this.createMaxConnectTimeGenerator();\n    this.connectionParams = this.getConnectionParams(connectionParams);\n    this.wsOptionArguments = wsOptionArguments;\n    if (!this.lazy) {\n      this.connect();\n    }\n  }\n  Object.defineProperty(SubscriptionClient.prototype, \"status\", {\n    get: function () {\n      if (this.client === null) {\n        return this.wsImpl.CLOSED;\n      }\n      return this.client.readyState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  SubscriptionClient.prototype.close = function (isForced, closedByUser) {\n    if (isForced === void 0) {\n      isForced = true;\n    }\n    if (closedByUser === void 0) {\n      closedByUser = true;\n    }\n    this.clearInactivityTimeout();\n    if (this.client !== null) {\n      this.closedByUser = closedByUser;\n      if (isForced) {\n        this.clearCheckConnectionInterval();\n        this.clearMaxConnectTimeout();\n        this.clearTryReconnectTimeout();\n        this.unsubscribeAll();\n        this.sendMessage(undefined, message_types_1.default.GQL_CONNECTION_TERMINATE, null);\n      }\n      this.client.close();\n      this.client.onopen = null;\n      this.client.onclose = null;\n      this.client.onerror = null;\n      this.client.onmessage = null;\n      this.client = null;\n      this.eventEmitter.emit('disconnected');\n      if (!isForced) {\n        this.tryReconnect();\n      }\n    }\n  };\n  SubscriptionClient.prototype.request = function (request) {\n    var _a;\n    var getObserver = this.getObserver.bind(this);\n    var executeOperation = this.executeOperation.bind(this);\n    var unsubscribe = this.unsubscribe.bind(this);\n    var opId;\n    this.clearInactivityTimeout();\n    return _a = {}, _a[symbol_observable_1.default] = function () {\n      return this;\n    }, _a.subscribe = function (observerOrNext, onError, onComplete) {\n      var observer = getObserver(observerOrNext, onError, onComplete);\n      opId = executeOperation(request, function (error, result) {\n        if (error === null && result === null) {\n          if (observer.complete) {\n            observer.complete();\n          }\n        } else if (error) {\n          if (observer.error) {\n            observer.error(error[0]);\n          }\n        } else {\n          if (observer.next) {\n            observer.next(result);\n          }\n        }\n      });\n      return {\n        unsubscribe: function () {\n          if (opId) {\n            unsubscribe(opId);\n            opId = null;\n          }\n        }\n      };\n    }, _a;\n  };\n  SubscriptionClient.prototype.on = function (eventName, callback, context) {\n    var handler = this.eventEmitter.on(eventName, callback, context);\n    return function () {\n      handler.off(eventName, callback, context);\n    };\n  };\n  SubscriptionClient.prototype.onConnected = function (callback, context) {\n    return this.on('connected', callback, context);\n  };\n  SubscriptionClient.prototype.onConnecting = function (callback, context) {\n    return this.on('connecting', callback, context);\n  };\n  SubscriptionClient.prototype.onDisconnected = function (callback, context) {\n    return this.on('disconnected', callback, context);\n  };\n  SubscriptionClient.prototype.onReconnected = function (callback, context) {\n    return this.on('reconnected', callback, context);\n  };\n  SubscriptionClient.prototype.onReconnecting = function (callback, context) {\n    return this.on('reconnecting', callback, context);\n  };\n  SubscriptionClient.prototype.onError = function (callback, context) {\n    return this.on('error', callback, context);\n  };\n  SubscriptionClient.prototype.unsubscribeAll = function () {\n    var _this = this;\n    Object.keys(this.operations).forEach(function (subId) {\n      _this.unsubscribe(subId);\n    });\n  };\n  SubscriptionClient.prototype.applyMiddlewares = function (options) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      var queue = function (funcs, scope) {\n        var next = function (error) {\n          if (error) {\n            reject(error);\n          } else {\n            if (funcs.length > 0) {\n              var f = funcs.shift();\n              if (f) {\n                f.applyMiddleware.apply(scope, [options, next]);\n              }\n            } else {\n              resolve(options);\n            }\n          }\n        };\n        next();\n      };\n      queue(__spreadArray([], _this.middlewares, true), _this);\n    });\n  };\n  SubscriptionClient.prototype.use = function (middlewares) {\n    var _this = this;\n    middlewares.map(function (middleware) {\n      if (typeof middleware.applyMiddleware === 'function') {\n        _this.middlewares.push(middleware);\n      } else {\n        throw new Error('Middleware must implement the applyMiddleware function.');\n      }\n    });\n    return this;\n  };\n  SubscriptionClient.prototype.getConnectionParams = function (connectionParams) {\n    return function () {\n      return new Promise(function (resolve, reject) {\n        if (typeof connectionParams === 'function') {\n          try {\n            return resolve(connectionParams.call(null));\n          } catch (error) {\n            return reject(error);\n          }\n        }\n        resolve(connectionParams);\n      });\n    };\n  };\n  SubscriptionClient.prototype.executeOperation = function (options, handler) {\n    var _this = this;\n    if (this.client === null) {\n      this.connect();\n    }\n    var opId = this.generateOperationId();\n    this.operations[opId] = {\n      options: options,\n      handler: handler\n    };\n    this.applyMiddlewares(options).then(function (processedOptions) {\n      _this.checkOperationOptions(processedOptions, handler);\n      if (_this.operations[opId]) {\n        _this.operations[opId] = {\n          options: processedOptions,\n          handler: handler\n        };\n        _this.sendMessage(opId, message_types_1.default.GQL_START, processedOptions);\n      }\n    }).catch(function (error) {\n      _this.unsubscribe(opId);\n      handler(_this.formatErrors(error));\n    });\n    return opId;\n  };\n  SubscriptionClient.prototype.getObserver = function (observerOrNext, error, complete) {\n    if (typeof observerOrNext === 'function') {\n      return {\n        next: function (v) {\n          return observerOrNext(v);\n        },\n        error: function (e) {\n          return error && error(e);\n        },\n        complete: function () {\n          return complete && complete();\n        }\n      };\n    }\n    return observerOrNext;\n  };\n  SubscriptionClient.prototype.createMaxConnectTimeGenerator = function () {\n    var minValue = this.minWsTimeout;\n    var maxValue = this.wsTimeout;\n    return new Backoff({\n      min: minValue,\n      max: maxValue,\n      factor: 1.2\n    });\n  };\n  SubscriptionClient.prototype.clearCheckConnectionInterval = function () {\n    if (this.checkConnectionIntervalId) {\n      clearInterval(this.checkConnectionIntervalId);\n      this.checkConnectionIntervalId = null;\n    }\n  };\n  SubscriptionClient.prototype.clearMaxConnectTimeout = function () {\n    if (this.maxConnectTimeoutId) {\n      clearTimeout(this.maxConnectTimeoutId);\n      this.maxConnectTimeoutId = null;\n    }\n  };\n  SubscriptionClient.prototype.clearTryReconnectTimeout = function () {\n    if (this.tryReconnectTimeoutId) {\n      clearTimeout(this.tryReconnectTimeoutId);\n      this.tryReconnectTimeoutId = null;\n    }\n  };\n  SubscriptionClient.prototype.clearInactivityTimeout = function () {\n    if (this.inactivityTimeoutId) {\n      clearTimeout(this.inactivityTimeoutId);\n      this.inactivityTimeoutId = null;\n    }\n  };\n  SubscriptionClient.prototype.setInactivityTimeout = function () {\n    var _this = this;\n    if (this.inactivityTimeout > 0 && Object.keys(this.operations).length === 0) {\n      this.inactivityTimeoutId = setTimeout(function () {\n        if (Object.keys(_this.operations).length === 0) {\n          _this.close();\n        }\n      }, this.inactivityTimeout);\n    }\n  };\n  SubscriptionClient.prototype.checkOperationOptions = function (options, handler) {\n    var query = options.query,\n      variables = options.variables,\n      operationName = options.operationName;\n    if (!query) {\n      throw new Error('Must provide a query.');\n    }\n    if (!handler) {\n      throw new Error('Must provide an handler.');\n    }\n    if (!(0, is_string_1.default)(query) && !(0, getOperationAST_1.getOperationAST)(query, operationName) || operationName && !(0, is_string_1.default)(operationName) || variables && !(0, is_object_1.default)(variables)) {\n      throw new Error('Incorrect option types. query must be a string or a document,' + '`operationName` must be a string, and `variables` must be an object.');\n    }\n  };\n  SubscriptionClient.prototype.buildMessage = function (id, type, payload) {\n    var payloadToReturn = payload && payload.query ? __assign(__assign({}, payload), {\n      query: typeof payload.query === 'string' ? payload.query : (0, printer_1.print)(payload.query)\n    }) : payload;\n    return {\n      id: id,\n      type: type,\n      payload: payloadToReturn\n    };\n  };\n  SubscriptionClient.prototype.formatErrors = function (errors) {\n    if (Array.isArray(errors)) {\n      return errors;\n    }\n    if (errors && errors.errors) {\n      return this.formatErrors(errors.errors);\n    }\n    if (errors && errors.message) {\n      return [errors];\n    }\n    return [{\n      name: 'FormatedError',\n      message: 'Unknown error',\n      originalError: errors\n    }];\n  };\n  SubscriptionClient.prototype.sendMessage = function (id, type, payload) {\n    this.sendMessageRaw(this.buildMessage(id, type, payload));\n  };\n  SubscriptionClient.prototype.sendMessageRaw = function (message) {\n    switch (this.status) {\n      case this.wsImpl.OPEN:\n        var serializedMessage = JSON.stringify(message);\n        try {\n          JSON.parse(serializedMessage);\n        } catch (e) {\n          this.eventEmitter.emit('error', new Error(\"Message must be JSON-serializable. Got: \" + message));\n        }\n        this.client.send(serializedMessage);\n        break;\n      case this.wsImpl.CONNECTING:\n        this.unsentMessagesQueue.push(message);\n        break;\n      default:\n        if (!this.reconnecting) {\n          this.eventEmitter.emit('error', new Error('A message was not sent because socket is not connected, is closing or ' + 'is already closed. Message was: ' + JSON.stringify(message)));\n        }\n    }\n  };\n  SubscriptionClient.prototype.generateOperationId = function () {\n    return String(++this.nextOperationId);\n  };\n  SubscriptionClient.prototype.tryReconnect = function () {\n    var _this = this;\n    if (!this.reconnect || this.backoff.attempts >= this.reconnectionAttempts) {\n      return;\n    }\n    if (!this.reconnecting) {\n      Object.keys(this.operations).forEach(function (key) {\n        _this.unsentMessagesQueue.push(_this.buildMessage(key, message_types_1.default.GQL_START, _this.operations[key].options));\n      });\n      this.reconnecting = true;\n    }\n    this.clearTryReconnectTimeout();\n    var delay = this.backoff.duration();\n    this.tryReconnectTimeoutId = setTimeout(function () {\n      _this.connect();\n    }, delay);\n  };\n  SubscriptionClient.prototype.flushUnsentMessagesQueue = function () {\n    var _this = this;\n    this.unsentMessagesQueue.forEach(function (message) {\n      _this.sendMessageRaw(message);\n    });\n    this.unsentMessagesQueue = [];\n  };\n  SubscriptionClient.prototype.checkConnection = function () {\n    if (this.wasKeepAliveReceived) {\n      this.wasKeepAliveReceived = false;\n      return;\n    }\n    if (!this.reconnecting) {\n      this.close(false, true);\n    }\n  };\n  SubscriptionClient.prototype.checkMaxConnectTimeout = function () {\n    var _this = this;\n    this.clearMaxConnectTimeout();\n    this.maxConnectTimeoutId = setTimeout(function () {\n      if (_this.status !== _this.wsImpl.OPEN) {\n        _this.reconnecting = true;\n        _this.close(false, true);\n      }\n    }, this.maxConnectTimeGenerator.duration());\n  };\n  SubscriptionClient.prototype.connect = function () {\n    var _a;\n    var _this = this;\n    this.client = new ((_a = this.wsImpl).bind.apply(_a, __spreadArray([void 0, this.url, this.wsProtocols], this.wsOptionArguments, false)))();\n    this.checkMaxConnectTimeout();\n    this.client.onopen = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var connectionParams, error_1;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!(this.status === this.wsImpl.OPEN)) return [3, 4];\n              this.clearMaxConnectTimeout();\n              this.closedByUser = false;\n              this.eventEmitter.emit(this.reconnecting ? 'reconnecting' : 'connecting');\n              _a.label = 1;\n            case 1:\n              _a.trys.push([1, 3,, 4]);\n              return [4, this.connectionParams()];\n            case 2:\n              connectionParams = _a.sent();\n              this.sendMessage(undefined, message_types_1.default.GQL_CONNECTION_INIT, connectionParams);\n              this.flushUnsentMessagesQueue();\n              return [3, 4];\n            case 3:\n              error_1 = _a.sent();\n              this.sendMessage(undefined, message_types_1.default.GQL_CONNECTION_ERROR, error_1);\n              this.flushUnsentMessagesQueue();\n              return [3, 4];\n            case 4:\n              return [2];\n          }\n        });\n      });\n    };\n    this.client.onclose = function () {\n      if (!_this.closedByUser) {\n        _this.close(false, false);\n      }\n    };\n    this.client.onerror = function (err) {\n      _this.eventEmitter.emit('error', err);\n    };\n    this.client.onmessage = function (_a) {\n      var data = _a.data;\n      _this.processReceivedData(data);\n    };\n  };\n  SubscriptionClient.prototype.processReceivedData = function (receivedData) {\n    var parsedMessage;\n    var opId;\n    try {\n      parsedMessage = JSON.parse(receivedData);\n      opId = parsedMessage.id;\n    } catch (e) {\n      throw new Error(\"Message must be JSON-parseable. Got: \" + receivedData);\n    }\n    if ([message_types_1.default.GQL_DATA, message_types_1.default.GQL_COMPLETE, message_types_1.default.GQL_ERROR].indexOf(parsedMessage.type) !== -1 && !this.operations[opId]) {\n      this.unsubscribe(opId);\n      return;\n    }\n    switch (parsedMessage.type) {\n      case message_types_1.default.GQL_CONNECTION_ERROR:\n        if (this.connectionCallback) {\n          this.connectionCallback(parsedMessage.payload);\n        }\n        break;\n      case message_types_1.default.GQL_CONNECTION_ACK:\n        this.eventEmitter.emit(this.reconnecting ? 'reconnected' : 'connected', parsedMessage.payload);\n        this.reconnecting = false;\n        this.backoff.reset();\n        this.maxConnectTimeGenerator.reset();\n        if (this.connectionCallback) {\n          this.connectionCallback();\n        }\n        break;\n      case message_types_1.default.GQL_COMPLETE:\n        var handler = this.operations[opId].handler;\n        delete this.operations[opId];\n        handler.call(this, null, null);\n        break;\n      case message_types_1.default.GQL_ERROR:\n        this.operations[opId].handler(this.formatErrors(parsedMessage.payload), null);\n        delete this.operations[opId];\n        break;\n      case message_types_1.default.GQL_DATA:\n        var parsedPayload = !parsedMessage.payload.errors ? parsedMessage.payload : __assign(__assign({}, parsedMessage.payload), {\n          errors: this.formatErrors(parsedMessage.payload.errors)\n        });\n        this.operations[opId].handler(null, parsedPayload);\n        break;\n      case message_types_1.default.GQL_CONNECTION_KEEP_ALIVE:\n        var firstKA = typeof this.wasKeepAliveReceived === 'undefined';\n        this.wasKeepAliveReceived = true;\n        if (firstKA) {\n          this.checkConnection();\n        }\n        if (this.checkConnectionIntervalId) {\n          clearInterval(this.checkConnectionIntervalId);\n          this.checkConnection();\n        }\n        this.checkConnectionIntervalId = setInterval(this.checkConnection.bind(this), this.wsTimeout);\n        break;\n      default:\n        throw new Error('Invalid message type!');\n    }\n  };\n  SubscriptionClient.prototype.unsubscribe = function (opId) {\n    if (this.operations[opId]) {\n      delete this.operations[opId];\n      this.setInactivityTimeout();\n      this.sendMessage(opId, message_types_1.default.GQL_STOP, undefined);\n    }\n  };\n  return SubscriptionClient;\n}();\nexports.SubscriptionClient = SubscriptionClient;","map":{"version":3,"names":["_global","global","window","NativeWebSocket","WebSocket","MozWebSocket","Backoff","require","eventemitter3_1","is_string_1","is_object_1","printer_1","getOperationAST_1","symbol_observable_1","protocol_1","defaults_1","message_types_1","SubscriptionClient","url","options","webSocketImpl","webSocketProtocols","_a","_b","connectionCallback","undefined","_c","connectionParams","_d","minTimeout","MIN_WS_TIMEOUT","_e","timeout","WS_TIMEOUT","_f","reconnect","_g","reconnectionAttempts","Infinity","_h","lazy","_j","inactivityTimeout","_k","wsOptionArguments","wsImpl","Error","wsProtocols","GRAPHQL_WS","operations","nextOperationId","minWsTimeout","wsTimeout","unsentMessagesQueue","reconnecting","closedByUser","backoff","jitter","eventEmitter","EventEmitter","middlewares","client","maxConnectTimeGenerator","createMaxConnectTimeGenerator","getConnectionParams","connect","Object","defineProperty","prototype","get","CLOSED","readyState","close","isForced","clearInactivityTimeout","clearCheckConnectionInterval","clearMaxConnectTimeout","clearTryReconnectTimeout","unsubscribeAll","sendMessage","default","GQL_CONNECTION_TERMINATE","onopen","onclose","onerror","onmessage","emit","tryReconnect","request","getObserver","bind","executeOperation","unsubscribe","opId","subscribe","observerOrNext","onError","onComplete","observer","error","result","complete","next","on","eventName","callback","context","handler","off","onConnected","onConnecting","onDisconnected","onReconnected","onReconnecting","_this","keys","forEach","subId","applyMiddlewares","Promise","resolve","reject","queue","funcs","scope","length","f","shift","applyMiddleware","apply","__spreadArray","use","map","middleware","push","call","generateOperationId","then","processedOptions","checkOperationOptions","GQL_START","catch","formatErrors","v","e","minValue","maxValue","min","max","factor","checkConnectionIntervalId","clearInterval","maxConnectTimeoutId","clearTimeout","tryReconnectTimeoutId","inactivityTimeoutId","setInactivityTimeout","setTimeout","query","variables","operationName","getOperationAST","buildMessage","id","type","payload","payloadToReturn","__assign","print","errors","Array","isArray","message","name","originalError","sendMessageRaw","status","OPEN","serializedMessage","JSON","stringify","parse","send","CONNECTING","String","attempts","key","delay","duration","flushUnsentMessagesQueue","checkConnection","wasKeepAliveReceived","checkMaxConnectTimeout","__awaiter","sent","GQL_CONNECTION_INIT","GQL_CONNECTION_ERROR","error_1","err","data","processReceivedData","receivedData","parsedMessage","GQL_DATA","GQL_COMPLETE","GQL_ERROR","indexOf","GQL_CONNECTION_ACK","reset","parsedPayload","GQL_CONNECTION_KEEP_ALIVE","firstKA","setInterval","GQL_STOP","exports"],"sources":["C:\\Users\\Clara\\Desktop\\GitProjects\\GRAPHQL\\voting-app-hasura\\client\\node_modules\\subscriptions-transport-ws\\src\\client.ts"],"sourcesContent":["declare let window: any;\nconst _global = typeof global !== 'undefined' ? global : (typeof window !== 'undefined' ? window : {});\nconst NativeWebSocket = _global.WebSocket || _global.MozWebSocket;\n\nimport * as Backoff from 'backo2';\nimport { default as EventEmitterType, EventEmitter, ListenerFn } from 'eventemitter3';\nimport isString from './utils/is-string';\nimport isObject from './utils/is-object';\nimport { ExecutionResult } from 'graphql/execution/execute';\nimport { print } from 'graphql/language/printer';\nimport { DocumentNode } from 'graphql/language/ast';\nimport { getOperationAST } from 'graphql/utilities/getOperationAST';\nimport $$observable from 'symbol-observable';\n\nimport { GRAPHQL_WS } from './protocol';\nimport { MIN_WS_TIMEOUT, WS_TIMEOUT } from './defaults';\nimport MessageTypes from './message-types';\n\nexport interface Observer<T> {\n  next?: (value: T) => void;\n  error?: (error: Error) => void;\n  complete?: () => void;\n}\n\nexport interface Observable<T> {\n  subscribe(observer: Observer<T>): {\n    unsubscribe: () => void;\n  };\n}\n\nexport interface OperationOptions {\n  query?: string | DocumentNode;\n  variables?: Object;\n  operationName?: string;\n  [key: string]: any;\n}\n\nexport type FormatedError = Error & {\n  originalError?: any;\n};\n\nexport interface Operation {\n  options: OperationOptions;\n  handler: (error: Error[], result?: any) => void;\n}\n\nexport interface Operations {\n  [id: string]: Operation;\n}\n\nexport interface Middleware {\n  applyMiddleware(options: OperationOptions, next: Function): void;\n}\n\nexport type ConnectionParams = {\n  [paramName: string]: any,\n};\n\nexport type ConnectionParamsOptions = ConnectionParams | Function | Promise<ConnectionParams>;\n\nexport interface ClientOptions {\n  connectionParams?: ConnectionParamsOptions;\n  minTimeout?: number;\n  timeout?: number;\n  reconnect?: boolean;\n  reconnectionAttempts?: number;\n  connectionCallback?: (error: Error[], result?: any) => void;\n  lazy?: boolean;\n  inactivityTimeout?: number;\n  wsOptionArguments?: any[];\n}\n\nexport class SubscriptionClient {\n  public client: any;\n  public operations: Operations;\n  private url: string;\n  private nextOperationId: number;\n  private connectionParams: Function;\n  private minWsTimeout: number;\n  private wsTimeout: number;\n  private unsentMessagesQueue: Array<any>; // queued messages while websocket is opening.\n  private reconnect: boolean;\n  private reconnecting: boolean;\n  private reconnectionAttempts: number;\n  private backoff: any;\n  private connectionCallback: any;\n  private eventEmitter: EventEmitterType;\n  private lazy: boolean;\n  private inactivityTimeout: number;\n  private inactivityTimeoutId: any;\n  private closedByUser: boolean;\n  private wsImpl: any;\n  private wsProtocols: string | string[];\n  private wasKeepAliveReceived: boolean;\n  private tryReconnectTimeoutId: any;\n  private checkConnectionIntervalId: any;\n  private maxConnectTimeoutId: any;\n  private middlewares: Middleware[];\n  private maxConnectTimeGenerator: any;\n  private wsOptionArguments: any[];\n\n  constructor(\n    url: string,\n    options?: ClientOptions,\n    webSocketImpl?: any,\n    webSocketProtocols?: string | string[],\n  ) {\n    const {\n      connectionCallback = undefined,\n      connectionParams = {},\n      minTimeout = MIN_WS_TIMEOUT,\n      timeout = WS_TIMEOUT,\n      reconnect = false,\n      reconnectionAttempts = Infinity,\n      lazy = false,\n      inactivityTimeout = 0,\n      wsOptionArguments = [],\n    } = (options || {});\n\n    this.wsImpl = webSocketImpl || NativeWebSocket;\n    if (!this.wsImpl) {\n      throw new Error('Unable to find native implementation, or alternative implementation for WebSocket!');\n    }\n\n    this.wsProtocols = webSocketProtocols || GRAPHQL_WS;\n    this.connectionCallback = connectionCallback;\n    this.url = url;\n    this.operations = {};\n    this.nextOperationId = 0;\n    this.minWsTimeout = minTimeout;\n    this.wsTimeout = timeout;\n    this.unsentMessagesQueue = [];\n    this.reconnect = reconnect;\n    this.reconnecting = false;\n    this.reconnectionAttempts = reconnectionAttempts;\n    this.lazy = !!lazy;\n    this.inactivityTimeout = inactivityTimeout;\n    this.closedByUser = false;\n    this.backoff = new Backoff({ jitter: 0.5 });\n    this.eventEmitter = new EventEmitter();\n    this.middlewares = [];\n    this.client = null;\n    this.maxConnectTimeGenerator = this.createMaxConnectTimeGenerator();\n    this.connectionParams = this.getConnectionParams(connectionParams);\n    this.wsOptionArguments = wsOptionArguments;\n\n    if (!this.lazy) {\n      this.connect();\n    }\n  }\n\n  public get status() {\n    if (this.client === null) {\n      return this.wsImpl.CLOSED;\n    }\n\n    return this.client.readyState;\n  }\n\n  public close(isForced = true, closedByUser = true) {\n    this.clearInactivityTimeout();\n    if (this.client !== null) {\n      this.closedByUser = closedByUser;\n\n      if (isForced) {\n        this.clearCheckConnectionInterval();\n        this.clearMaxConnectTimeout();\n        this.clearTryReconnectTimeout();\n        this.unsubscribeAll();\n        this.sendMessage(undefined, MessageTypes.GQL_CONNECTION_TERMINATE, null);\n      }\n\n      this.client.close();\n      this.client.onopen = null;\n      this.client.onclose = null;\n      this.client.onerror = null;\n      this.client.onmessage = null;\n      this.client = null;\n      this.eventEmitter.emit('disconnected');\n\n      if (!isForced) {\n        this.tryReconnect();\n      }\n    }\n  }\n\n  public request(request: OperationOptions): Observable<ExecutionResult> {\n    const getObserver = this.getObserver.bind(this);\n    const executeOperation = this.executeOperation.bind(this);\n    const unsubscribe = this.unsubscribe.bind(this);\n\n    let opId: string;\n\n    this.clearInactivityTimeout();\n\n    return {\n      [$$observable]() {\n        return this;\n      },\n      subscribe(\n        observerOrNext: ((Observer<ExecutionResult>) | ((v: ExecutionResult) => void)),\n        onError?: (error: Error) => void,\n        onComplete?: () => void,\n      ) {\n        const observer = getObserver(observerOrNext, onError, onComplete);\n\n        opId = executeOperation(request, (error: Error[], result: any) => {\n          if ( error === null && result === null ) {\n            if ( observer.complete ) {\n              observer.complete();\n            }\n          } else if (error) {\n            if ( observer.error ) {\n              observer.error(error[0]);\n            }\n          } else {\n            if ( observer.next ) {\n              observer.next(result);\n            }\n          }\n        });\n\n        return {\n          unsubscribe: () => {\n            if ( opId ) {\n              unsubscribe(opId);\n              opId = null;\n            }\n          },\n        };\n      },\n    };\n  }\n\n  public on(eventName: string, callback: ListenerFn, context?: any): Function {\n    const handler = this.eventEmitter.on(eventName, callback, context);\n\n    return () => {\n      handler.off(eventName, callback, context);\n    };\n  }\n\n  public onConnected(callback: ListenerFn, context?: any): Function {\n    return this.on('connected', callback, context);\n  }\n\n  public onConnecting(callback: ListenerFn, context?: any): Function {\n    return this.on('connecting', callback, context);\n  }\n\n  public onDisconnected(callback: ListenerFn, context?: any): Function {\n    return this.on('disconnected', callback, context);\n  }\n\n  public onReconnected(callback: ListenerFn, context?: any): Function {\n    return this.on('reconnected', callback, context);\n  }\n\n  public onReconnecting(callback: ListenerFn, context?: any): Function {\n    return this.on('reconnecting', callback, context);\n  }\n\n  public onError(callback: ListenerFn, context?: any): Function {\n    return this.on('error', callback, context);\n  }\n\n  public unsubscribeAll() {\n    Object.keys(this.operations).forEach( subId => {\n      this.unsubscribe(subId);\n    });\n  }\n\n  public applyMiddlewares(options: OperationOptions): Promise<OperationOptions> {\n    return new Promise((resolve, reject) => {\n      const queue = (funcs: Middleware[], scope: any) => {\n        const next = (error?: any) => {\n          if (error) {\n            reject(error);\n          } else {\n            if (funcs.length > 0) {\n              const f = funcs.shift();\n              if (f) {\n                f.applyMiddleware.apply(scope, [options, next]);\n              }\n            } else {\n              resolve(options);\n            }\n          }\n        };\n        next();\n      };\n\n      queue([...this.middlewares], this);\n    });\n  }\n\n  public use(middlewares: Middleware[]): SubscriptionClient {\n    middlewares.map((middleware) => {\n      if (typeof middleware.applyMiddleware === 'function') {\n        this.middlewares.push(middleware);\n      } else {\n        throw new Error('Middleware must implement the applyMiddleware function.');\n      }\n    });\n\n    return this;\n  }\n\n  private getConnectionParams(connectionParams: ConnectionParamsOptions): Function {\n    return (): Promise<ConnectionParams> => new Promise((resolve, reject) => {\n      if (typeof connectionParams === 'function') {\n        try {\n          return resolve(connectionParams.call(null));\n        } catch (error) {\n          return reject(error);\n        }\n      }\n\n      resolve(connectionParams);\n    });\n  }\n\n  private executeOperation(options: OperationOptions, handler: (error: Error[], result?: any) => void): string {\n    if (this.client === null) {\n      this.connect();\n    }\n\n    const opId = this.generateOperationId();\n    this.operations[opId] = { options: options, handler };\n\n    this.applyMiddlewares(options)\n      .then(processedOptions => {\n        this.checkOperationOptions(processedOptions, handler);\n        if (this.operations[opId]) {\n          this.operations[opId] = { options: processedOptions, handler };\n          this.sendMessage(opId, MessageTypes.GQL_START, processedOptions);\n        }\n      })\n      .catch(error => {\n        this.unsubscribe(opId);\n        handler(this.formatErrors(error));\n      });\n\n    return opId;\n  }\n\n  private getObserver<T>(\n    observerOrNext: ((Observer<T>) | ((v: T) => void)),\n    error?: (e: Error) => void,\n    complete?: () => void,\n  ) {\n    if ( typeof observerOrNext === 'function' ) {\n      return {\n        next: (v: T) => observerOrNext(v),\n        error: (e: Error) => error && error(e),\n        complete: () => complete && complete(),\n      };\n    }\n\n    return observerOrNext;\n  }\n\n  private createMaxConnectTimeGenerator() {\n    const minValue = this.minWsTimeout;\n    const maxValue = this.wsTimeout;\n\n    return new Backoff({\n      min: minValue,\n      max: maxValue,\n      factor: 1.2,\n    });\n  }\n\n  private clearCheckConnectionInterval() {\n    if (this.checkConnectionIntervalId) {\n      clearInterval(this.checkConnectionIntervalId);\n      this.checkConnectionIntervalId = null;\n    }\n  }\n\n  private clearMaxConnectTimeout() {\n    if (this.maxConnectTimeoutId) {\n      clearTimeout(this.maxConnectTimeoutId);\n      this.maxConnectTimeoutId = null;\n    }\n    }\n\n  private clearTryReconnectTimeout() {\n    if (this.tryReconnectTimeoutId) {\n      clearTimeout(this.tryReconnectTimeoutId);\n      this.tryReconnectTimeoutId = null;\n    }\n  }\n\n  private clearInactivityTimeout() {\n    if (this.inactivityTimeoutId) {\n      clearTimeout(this.inactivityTimeoutId);\n      this.inactivityTimeoutId = null;\n    }\n  }\n\n  private setInactivityTimeout() {\n    if (this.inactivityTimeout > 0 && Object.keys(this.operations).length === 0) {\n      this.inactivityTimeoutId = setTimeout(() => {\n        if (Object.keys(this.operations).length === 0) {\n          this.close();\n        }\n      }, this.inactivityTimeout);\n    }\n  }\n\n  private checkOperationOptions(options: OperationOptions, handler: (error: Error[], result?: any) => void) {\n    const { query, variables, operationName } = options;\n\n    if (!query) {\n      throw new Error('Must provide a query.');\n    }\n\n    if (!handler) {\n      throw new Error('Must provide an handler.');\n    }\n\n    if (\n      ( !isString(query) && !getOperationAST(query, operationName)) ||\n      ( operationName && !isString(operationName)) ||\n      ( variables && !isObject(variables))\n    ) {\n      throw new Error('Incorrect option types. query must be a string or a document,' +\n        '`operationName` must be a string, and `variables` must be an object.');\n    }\n  }\n\n  private buildMessage(id: string, type: string, payload: any) {\n    const payloadToReturn = payload && payload.query ?\n      {\n        ...payload,\n        query: typeof payload.query === 'string' ? payload.query : print(payload.query),\n      } :\n      payload;\n\n    return {\n      id,\n      type,\n      payload: payloadToReturn,\n    };\n  }\n\n  // ensure we have an array of errors\n  private formatErrors(errors: any): FormatedError[] {\n    if (Array.isArray(errors)) {\n      return errors;\n    }\n\n    // TODO  we should not pass ValidationError to callback in the future.\n    // ValidationError\n    if (errors && errors.errors) {\n      return this.formatErrors(errors.errors);\n    }\n\n    if (errors && errors.message) {\n      return [errors];\n    }\n\n    return [{\n      name: 'FormatedError',\n      message: 'Unknown error',\n      originalError: errors,\n    }];\n  }\n\n  private sendMessage(id: string, type: string, payload: any) {\n    this.sendMessageRaw(this.buildMessage(id, type, payload));\n  }\n\n  // send message, or queue it if connection is not open\n  private sendMessageRaw(message: Object) {\n    switch (this.status) {\n      case this.wsImpl.OPEN:\n        let serializedMessage: string = JSON.stringify(message);\n        try {\n          JSON.parse(serializedMessage);\n        } catch (e) {\n          this.eventEmitter.emit('error', new Error(`Message must be JSON-serializable. Got: ${message}`));\n        }\n\n        this.client.send(serializedMessage);\n        break;\n      case this.wsImpl.CONNECTING:\n        this.unsentMessagesQueue.push(message);\n\n        break;\n      default:\n        if (!this.reconnecting) {\n          this.eventEmitter.emit('error', new Error('A message was not sent because socket is not connected, is closing or ' +\n            'is already closed. Message was: ' + JSON.stringify(message)));\n        }\n    }\n  }\n\n  private generateOperationId(): string {\n    return String(++this.nextOperationId);\n  }\n\n  private tryReconnect() {\n    if (!this.reconnect || this.backoff.attempts >= this.reconnectionAttempts) {\n      return;\n    }\n\n    if (!this.reconnecting) {\n      Object.keys(this.operations).forEach((key) => {\n        this.unsentMessagesQueue.push(\n          this.buildMessage(key, MessageTypes.GQL_START, this.operations[key].options),\n        );\n      });\n      this.reconnecting = true;\n    }\n\n    this.clearTryReconnectTimeout();\n\n    const delay = this.backoff.duration();\n    this.tryReconnectTimeoutId = setTimeout(() => {\n      this.connect();\n    }, delay);\n  }\n\n  private flushUnsentMessagesQueue() {\n    this.unsentMessagesQueue.forEach((message) => {\n      this.sendMessageRaw(message);\n    });\n    this.unsentMessagesQueue = [];\n  }\n\n  private checkConnection() {\n    if (this.wasKeepAliveReceived) {\n      this.wasKeepAliveReceived = false;\n      return;\n    }\n\n    if (!this.reconnecting) {\n      this.close(false, true);\n    }\n  }\n\n  private checkMaxConnectTimeout() {\n    this.clearMaxConnectTimeout();\n\n    // Max timeout trying to connect\n    this.maxConnectTimeoutId = setTimeout(() => {\n      if (this.status !== this.wsImpl.OPEN) {\n        this.reconnecting = true;\n        this.close(false, true);\n      }\n    }, this.maxConnectTimeGenerator.duration());\n  }\n\n  private connect() {\n    this.client = new this.wsImpl(this.url, this.wsProtocols, ...this.wsOptionArguments);\n\n    this.checkMaxConnectTimeout();\n\n    this.client.onopen = async () => {\n      if (this.status === this.wsImpl.OPEN) {\n        this.clearMaxConnectTimeout();\n        this.closedByUser = false;\n        this.eventEmitter.emit(this.reconnecting ? 'reconnecting' : 'connecting');\n\n        try {\n          const connectionParams: ConnectionParams = await this.connectionParams();\n\n          // Send CONNECTION_INIT message, no need to wait for connection to success (reduce roundtrips)\n          this.sendMessage(undefined, MessageTypes.GQL_CONNECTION_INIT, connectionParams);\n          this.flushUnsentMessagesQueue();\n        } catch (error) {\n          this.sendMessage(undefined, MessageTypes.GQL_CONNECTION_ERROR, error);\n          this.flushUnsentMessagesQueue();\n        }\n      }\n    };\n\n    this.client.onclose = () => {\n      if (!this.closedByUser) {\n        this.close(false, false);\n      }\n    };\n\n    this.client.onerror = (err: Error) => {\n      // Capture and ignore errors to prevent unhandled exceptions, wait for\n      // onclose to fire before attempting a reconnect.\n      this.eventEmitter.emit('error', err);\n    };\n\n    this.client.onmessage = ({ data }: {data: any}) => {\n      this.processReceivedData(data);\n    };\n  }\n\n  private processReceivedData(receivedData: any) {\n    let parsedMessage: any;\n    let opId: string;\n\n    try {\n      parsedMessage = JSON.parse(receivedData);\n      opId = parsedMessage.id;\n    } catch (e) {\n      throw new Error(`Message must be JSON-parseable. Got: ${receivedData}`);\n    }\n\n    if (\n      [ MessageTypes.GQL_DATA,\n        MessageTypes.GQL_COMPLETE,\n        MessageTypes.GQL_ERROR,\n      ].indexOf(parsedMessage.type) !== -1 && !this.operations[opId]\n    ) {\n      this.unsubscribe(opId);\n\n      return;\n    }\n\n    switch (parsedMessage.type) {\n      case MessageTypes.GQL_CONNECTION_ERROR:\n        if (this.connectionCallback) {\n          this.connectionCallback(parsedMessage.payload);\n        }\n        break;\n\n      case MessageTypes.GQL_CONNECTION_ACK:\n        this.eventEmitter.emit(this.reconnecting ? 'reconnected' : 'connected', parsedMessage.payload);\n        this.reconnecting = false;\n        this.backoff.reset();\n        this.maxConnectTimeGenerator.reset();\n\n        if (this.connectionCallback) {\n          this.connectionCallback();\n        }\n        break;\n\n      case MessageTypes.GQL_COMPLETE:\n        const handler = this.operations[opId].handler;\n        delete this.operations[opId];\n        handler.call(this, null, null);\n        break;\n\n      case MessageTypes.GQL_ERROR:\n        this.operations[opId].handler(this.formatErrors(parsedMessage.payload), null);\n        delete this.operations[opId];\n        break;\n\n      case MessageTypes.GQL_DATA:\n        const parsedPayload = !parsedMessage.payload.errors ?\n          parsedMessage.payload : {...parsedMessage.payload, errors: this.formatErrors(parsedMessage.payload.errors)};\n        this.operations[opId].handler(null, parsedPayload);\n        break;\n\n      case MessageTypes.GQL_CONNECTION_KEEP_ALIVE:\n        const firstKA = typeof this.wasKeepAliveReceived === 'undefined';\n        this.wasKeepAliveReceived = true;\n\n        if (firstKA) {\n          this.checkConnection();\n        }\n\n        if (this.checkConnectionIntervalId) {\n          clearInterval(this.checkConnectionIntervalId);\n          this.checkConnection();\n        }\n        this.checkConnectionIntervalId = setInterval(this.checkConnection.bind(this), this.wsTimeout);\n        break;\n\n      default:\n        throw new Error('Invalid message type!');\n    }\n  }\n\n  private unsubscribe(opId: string) {\n    if (this.operations[opId]) {\n      delete this.operations[opId];\n      this.setInactivityTimeout();\n      this.sendMessage(opId, MessageTypes.GQL_STOP, undefined);\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,IAAMA,OAAO,GAAG,OAAOC,MAAM,KAAK,WAAW,GAAGA,MAAM,GAAI,OAAOC,MAAM,KAAK,WAAW,GAAGA,MAAM,GAAG,EAAG;AACtG,IAAMC,eAAe,GAAGH,OAAO,CAACI,SAAS,IAAIJ,OAAO,CAACK,YAAY;AAEjE,IAAAC,OAAA,GAAAC,OAAA;AACA,IAAAC,eAAA,GAAAD,OAAA;AACA,IAAAE,WAAA,GAAAF,OAAA;AACA,IAAAG,WAAA,GAAAH,OAAA;AAEA,IAAAI,SAAA,GAAAJ,OAAA;AAEA,IAAAK,iBAAA,GAAAL,OAAA;AACA,IAAAM,mBAAA,GAAAN,OAAA;AAEA,IAAAO,UAAA,GAAAP,OAAA;AACA,IAAAQ,UAAA,GAAAR,OAAA;AACA,IAAAS,eAAA,GAAAT,OAAA;AAwDA,IAAAU,kBAAA;EA6BE,SAAAA,mBACEC,GAAW,EACXC,OAAuB,EACvBC,aAAmB,EACnBC,kBAAsC;IAEhC,IAAAC,EAAA,GAUDH,OAAO,IAAI,EAAG;MATjBI,EAAA,GAAAD,EAAA,CAAAE,kBAA8B;MAA9BA,kBAAkB,GAAAD,EAAA,cAAGE,SAAS,GAAAF,EAAA;MAC9BG,EAAA,GAAAJ,EAAA,CAAAK,gBAAqB;MAArBA,gBAAgB,GAAAD,EAAA,cAAG,EAAE,GAAAA,EAAA;MACrBE,EAAA,GAAAN,EAAA,CAAAO,UAA2B;MAA3BA,UAAU,GAAAD,EAAA,cAAGb,UAAA,CAAAe,cAAc,GAAAF,EAAA;MAC3BG,EAAA,GAAAT,EAAA,CAAAU,OAAoB;MAApBA,OAAO,GAAAD,EAAA,cAAGhB,UAAA,CAAAkB,UAAU,GAAAF,EAAA;MACpBG,EAAA,GAAAZ,EAAA,CAAAa,SAAiB;MAAjBA,SAAS,GAAAD,EAAA,cAAG,KAAK,GAAAA,EAAA;MACjBE,EAAA,GAAAd,EAAA,CAAAe,oBAA+B;MAA/BA,oBAAoB,GAAAD,EAAA,cAAGE,QAAQ,GAAAF,EAAA;MAC/BG,EAAA,GAAAjB,EAAA,CAAAkB,IAAY;MAAZA,IAAI,GAAAD,EAAA,cAAG,KAAK,GAAAA,EAAA;MACZE,EAAA,GAAAnB,EAAA,CAAAoB,iBAAqB;MAArBA,iBAAiB,GAAAD,EAAA,cAAG,CAAC,GAAAA,EAAA;MACrBE,EAAA,GAAArB,EAAA,CAAAsB,iBAAsB;MAAtBA,iBAAiB,GAAAD,EAAA,cAAG,EAAE,GAAAA,EACL;IAEnB,IAAI,CAACE,MAAM,GAAGzB,aAAa,IAAIjB,eAAe;IAC9C,IAAI,CAAC,IAAI,CAAC0C,MAAM,EAAE;MAChB,MAAM,IAAIC,KAAK,CAAC,oFAAoF,CAAC;;IAGvG,IAAI,CAACC,WAAW,GAAG1B,kBAAkB,IAAIP,UAAA,CAAAkC,UAAU;IACnD,IAAI,CAACxB,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACN,GAAG,GAAGA,GAAG;IACd,IAAI,CAAC+B,UAAU,GAAG,EAAE;IACpB,IAAI,CAACC,eAAe,GAAG,CAAC;IACxB,IAAI,CAACC,YAAY,GAAGtB,UAAU;IAC9B,IAAI,CAACuB,SAAS,GAAGpB,OAAO;IACxB,IAAI,CAACqB,mBAAmB,GAAG,EAAE;IAC7B,IAAI,CAAClB,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACmB,YAAY,GAAG,KAAK;IACzB,IAAI,CAACjB,oBAAoB,GAAGA,oBAAoB;IAChD,IAAI,CAACG,IAAI,GAAG,CAAC,CAACA,IAAI;IAClB,IAAI,CAACE,iBAAiB,GAAGA,iBAAiB;IAC1C,IAAI,CAACa,YAAY,GAAG,KAAK;IACzB,IAAI,CAACC,OAAO,GAAG,IAAIlD,OAAO,CAAC;MAAEmD,MAAM,EAAE;IAAG,CAAE,CAAC;IAC3C,IAAI,CAACC,YAAY,GAAG,IAAIlD,eAAA,CAAAmD,YAAY,EAAE;IACtC,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB,IAAI,CAACC,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,uBAAuB,GAAG,IAAI,CAACC,6BAA6B,EAAE;IACnE,IAAI,CAACpC,gBAAgB,GAAG,IAAI,CAACqC,mBAAmB,CAACrC,gBAAgB,CAAC;IAClE,IAAI,CAACiB,iBAAiB,GAAGA,iBAAiB;IAE1C,IAAI,CAAC,IAAI,CAACJ,IAAI,EAAE;MACd,IAAI,CAACyB,OAAO,EAAE;;EAElB;EAEAC,MAAA,CAAAC,cAAA,CAAWlD,kBAAA,CAAAmD,SAAA,UAAM;SAAjB,SAAAC,CAAA;MACE,IAAI,IAAI,CAACR,MAAM,KAAK,IAAI,EAAE;QACxB,OAAO,IAAI,CAAChB,MAAM,CAACyB,MAAM;;MAG3B,OAAO,IAAI,CAACT,MAAM,CAACU,UAAU;IAC/B,CAAC;;;;EAEMtD,kBAAA,CAAAmD,SAAA,CAAAI,KAAK,GAAZ,UAAaC,QAAe,EAAElB,YAAmB;IAApC,IAAAkB,QAAA;MAAAA,QAAA,OAAe;IAAA;IAAE,IAAAlB,YAAA;MAAAA,YAAA,OAAmB;IAAA;IAC/C,IAAI,CAACmB,sBAAsB,EAAE;IAC7B,IAAI,IAAI,CAACb,MAAM,KAAK,IAAI,EAAE;MACxB,IAAI,CAACN,YAAY,GAAGA,YAAY;MAEhC,IAAIkB,QAAQ,EAAE;QACZ,IAAI,CAACE,4BAA4B,EAAE;QACnC,IAAI,CAACC,sBAAsB,EAAE;QAC7B,IAAI,CAACC,wBAAwB,EAAE;QAC/B,IAAI,CAACC,cAAc,EAAE;QACrB,IAAI,CAACC,WAAW,CAACtD,SAAS,EAAET,eAAA,CAAAgE,OAAY,CAACC,wBAAwB,EAAE,IAAI,CAAC;;MAG1E,IAAI,CAACpB,MAAM,CAACW,KAAK,EAAE;MACnB,IAAI,CAACX,MAAM,CAACqB,MAAM,GAAG,IAAI;MACzB,IAAI,CAACrB,MAAM,CAACsB,OAAO,GAAG,IAAI;MAC1B,IAAI,CAACtB,MAAM,CAACuB,OAAO,GAAG,IAAI;MAC1B,IAAI,CAACvB,MAAM,CAACwB,SAAS,GAAG,IAAI;MAC5B,IAAI,CAACxB,MAAM,GAAG,IAAI;MAClB,IAAI,CAACH,YAAY,CAAC4B,IAAI,CAAC,cAAc,CAAC;MAEtC,IAAI,CAACb,QAAQ,EAAE;QACb,IAAI,CAACc,YAAY,EAAE;;;EAGzB,CAAC;EAEMtE,kBAAA,CAAAmD,SAAA,CAAAoB,OAAO,GAAd,UAAeA,OAAyB;;IACtC,IAAMC,WAAW,GAAG,IAAI,CAACA,WAAW,CAACC,IAAI,CAAC,IAAI,CAAC;IAC/C,IAAMC,gBAAgB,GAAG,IAAI,CAACA,gBAAgB,CAACD,IAAI,CAAC,IAAI,CAAC;IACzD,IAAME,WAAW,GAAG,IAAI,CAACA,WAAW,CAACF,IAAI,CAAC,IAAI,CAAC;IAE/C,IAAIG,IAAY;IAEhB,IAAI,CAACnB,sBAAsB,EAAE;IAE7B,OAAApD,EAAA,OACEA,EAAA,CAACT,mBAAA,CAAAmE,OAAY,IAAb;MACE,OAAO,IAAI;IACb,CAAC,EACD1D,EAAA,CAAAwE,SAAS,GAAT,UACEC,cAA8E,EAC9EC,OAAgC,EAChCC,UAAuB;MAEvB,IAAMC,QAAQ,GAAGT,WAAW,CAACM,cAAc,EAAEC,OAAO,EAAEC,UAAU,CAAC;MAEjEJ,IAAI,GAAGF,gBAAgB,CAACH,OAAO,EAAE,UAACW,KAAc,EAAEC,MAAW;QAC3D,IAAKD,KAAK,KAAK,IAAI,IAAIC,MAAM,KAAK,IAAI,EAAG;UACvC,IAAKF,QAAQ,CAACG,QAAQ,EAAG;YACvBH,QAAQ,CAACG,QAAQ,EAAE;;SAEtB,MAAM,IAAIF,KAAK,EAAE;UAChB,IAAKD,QAAQ,CAACC,KAAK,EAAG;YACpBD,QAAQ,CAACC,KAAK,CAACA,KAAK,CAAC,CAAC,CAAC,CAAC;;SAE3B,MAAM;UACL,IAAKD,QAAQ,CAACI,IAAI,EAAG;YACnBJ,QAAQ,CAACI,IAAI,CAACF,MAAM,CAAC;;;MAG3B,CAAC,CAAC;MAEF,OAAO;QACLR,WAAW,EAAE,SAAAA,CAAA;UACX,IAAKC,IAAI,EAAG;YACVD,WAAW,CAACC,IAAI,CAAC;YACjBA,IAAI,GAAG,IAAI;;QAEf;OACD;IACH,CAAC,E;EAEL,CAAC;EAEM5E,kBAAA,CAAAmD,SAAA,CAAAmC,EAAE,GAAT,UAAUC,SAAiB,EAAEC,QAAoB,EAAEC,OAAa;IAC9D,IAAMC,OAAO,GAAG,IAAI,CAACjD,YAAY,CAAC6C,EAAE,CAACC,SAAS,EAAEC,QAAQ,EAAEC,OAAO,CAAC;IAElE,OAAO;MACLC,OAAO,CAACC,GAAG,CAACJ,SAAS,EAAEC,QAAQ,EAAEC,OAAO,CAAC;IAC3C,CAAC;EACH,CAAC;EAEMzF,kBAAA,CAAAmD,SAAA,CAAAyC,WAAW,GAAlB,UAAmBJ,QAAoB,EAAEC,OAAa;IACpD,OAAO,IAAI,CAACH,EAAE,CAAC,WAAW,EAAEE,QAAQ,EAAEC,OAAO,CAAC;EAChD,CAAC;EAEMzF,kBAAA,CAAAmD,SAAA,CAAA0C,YAAY,GAAnB,UAAoBL,QAAoB,EAAEC,OAAa;IACrD,OAAO,IAAI,CAACH,EAAE,CAAC,YAAY,EAAEE,QAAQ,EAAEC,OAAO,CAAC;EACjD,CAAC;EAEMzF,kBAAA,CAAAmD,SAAA,CAAA2C,cAAc,GAArB,UAAsBN,QAAoB,EAAEC,OAAa;IACvD,OAAO,IAAI,CAACH,EAAE,CAAC,cAAc,EAAEE,QAAQ,EAAEC,OAAO,CAAC;EACnD,CAAC;EAEMzF,kBAAA,CAAAmD,SAAA,CAAA4C,aAAa,GAApB,UAAqBP,QAAoB,EAAEC,OAAa;IACtD,OAAO,IAAI,CAACH,EAAE,CAAC,aAAa,EAAEE,QAAQ,EAAEC,OAAO,CAAC;EAClD,CAAC;EAEMzF,kBAAA,CAAAmD,SAAA,CAAA6C,cAAc,GAArB,UAAsBR,QAAoB,EAAEC,OAAa;IACvD,OAAO,IAAI,CAACH,EAAE,CAAC,cAAc,EAAEE,QAAQ,EAAEC,OAAO,CAAC;EACnD,CAAC;EAEMzF,kBAAA,CAAAmD,SAAA,CAAA4B,OAAO,GAAd,UAAeS,QAAoB,EAAEC,OAAa;IAChD,OAAO,IAAI,CAACH,EAAE,CAAC,OAAO,EAAEE,QAAQ,EAAEC,OAAO,CAAC;EAC5C,CAAC;EAEMzF,kBAAA,CAAAmD,SAAA,CAAAU,cAAc,GAArB;IAAA,IAAAoC,KAAA;IACEhD,MAAM,CAACiD,IAAI,CAAC,IAAI,CAAClE,UAAU,CAAC,CAACmE,OAAO,CAAE,UAAAC,KAAK;MACzCH,KAAI,CAACtB,WAAW,CAACyB,KAAK,CAAC;IACzB,CAAC,CAAC;EACJ,CAAC;EAEMpG,kBAAA,CAAAmD,SAAA,CAAAkD,gBAAgB,GAAvB,UAAwBnG,OAAyB;IAAjD,IAAA+F,KAAA;IACE,OAAO,IAAIK,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM;MACjC,IAAMC,KAAK,GAAG,SAAAA,CAACC,KAAmB,EAAEC,KAAU;QAC5C,IAAMtB,IAAI,GAAG,SAAAA,CAACH,KAAW;UACvB,IAAIA,KAAK,EAAE;YACTsB,MAAM,CAACtB,KAAK,CAAC;WACd,MAAM;YACL,IAAIwB,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;cACpB,IAAMC,CAAC,GAAGH,KAAK,CAACI,KAAK,EAAE;cACvB,IAAID,CAAC,EAAE;gBACLA,CAAC,CAACE,eAAe,CAACC,KAAK,CAACL,KAAK,EAAE,CAACzG,OAAO,EAAEmF,IAAI,CAAC,CAAC;;aAElD,MAAM;cACLkB,OAAO,CAACrG,OAAO,CAAC;;;QAGtB,CAAC;QACDmF,IAAI,EAAE;MACR,CAAC;MAEDoB,KAAK,CAAAQ,aAAA,KAAKhB,KAAI,CAACtD,WAAW,SAAGsD,KAAI,CAAC;IACpC,CAAC,CAAC;EACJ,CAAC;EAEMjG,kBAAA,CAAAmD,SAAA,CAAA+D,GAAG,GAAV,UAAWvE,WAAyB;IAApC,IAAAsD,KAAA;IACEtD,WAAW,CAACwE,GAAG,CAAC,UAACC,UAAU;MACzB,IAAI,OAAOA,UAAU,CAACL,eAAe,KAAK,UAAU,EAAE;QACpDd,KAAI,CAACtD,WAAW,CAAC0E,IAAI,CAACD,UAAU,CAAC;OAClC,MAAM;QACL,MAAM,IAAIvF,KAAK,CAAC,yDAAyD,CAAC;;IAE9E,CAAC,CAAC;IAEF,OAAO,IAAI;EACb,CAAC;EAEO7B,kBAAA,CAAAmD,SAAA,CAAAJ,mBAAmB,GAA3B,UAA4BrC,gBAAyC;IACnE,OAAO;MAAiC,WAAI4F,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM;QAClE,IAAI,OAAO9F,gBAAgB,KAAK,UAAU,EAAE;UAC1C,IAAI;YACF,OAAO6F,OAAO,CAAC7F,gBAAgB,CAAC4G,IAAI,CAAC,IAAI,CAAC,CAAC;WAC5C,CAAC,OAAOpC,KAAK,EAAE;YACd,OAAOsB,MAAM,CAACtB,KAAK,CAAC;;;QAIxBqB,OAAO,CAAC7F,gBAAgB,CAAC;MAC3B,CAAC,CAAC;IAVsC,CAUtC;EACJ,CAAC;EAEOV,kBAAA,CAAAmD,SAAA,CAAAuB,gBAAgB,GAAxB,UAAyBxE,OAAyB,EAAEwF,OAA+C;IAAnG,IAAAO,KAAA;IACE,IAAI,IAAI,CAACrD,MAAM,KAAK,IAAI,EAAE;MACxB,IAAI,CAACI,OAAO,EAAE;;IAGhB,IAAM4B,IAAI,GAAG,IAAI,CAAC2C,mBAAmB,EAAE;IACvC,IAAI,CAACvF,UAAU,CAAC4C,IAAI,CAAC,GAAG;MAAE1E,OAAO,EAAEA,OAAO;MAAEwF,OAAO,EAAAA;IAAA,CAAE;IAErD,IAAI,CAACW,gBAAgB,CAACnG,OAAO,CAAC,CAC3BsH,IAAI,CAAC,UAAAC,gBAAgB;MACpBxB,KAAI,CAACyB,qBAAqB,CAACD,gBAAgB,EAAE/B,OAAO,CAAC;MACrD,IAAIO,KAAI,CAACjE,UAAU,CAAC4C,IAAI,CAAC,EAAE;QACzBqB,KAAI,CAACjE,UAAU,CAAC4C,IAAI,CAAC,GAAG;UAAE1E,OAAO,EAAEuH,gBAAgB;UAAE/B,OAAO,EAAAA;QAAA,CAAE;QAC9DO,KAAI,CAACnC,WAAW,CAACc,IAAI,EAAE7E,eAAA,CAAAgE,OAAY,CAAC4D,SAAS,EAAEF,gBAAgB,CAAC;;IAEpE,CAAC,CAAC,CACDG,KAAK,CAAC,UAAA1C,KAAK;MACVe,KAAI,CAACtB,WAAW,CAACC,IAAI,CAAC;MACtBc,OAAO,CAACO,KAAI,CAAC4B,YAAY,CAAC3C,KAAK,CAAC,CAAC;IACnC,CAAC,CAAC;IAEJ,OAAON,IAAI;EACb,CAAC;EAEO5E,kBAAA,CAAAmD,SAAA,CAAAqB,WAAW,GAAnB,UACEM,cAAkD,EAClDI,KAA0B,EAC1BE,QAAqB;IAErB,IAAK,OAAON,cAAc,KAAK,UAAU,EAAG;MAC1C,OAAO;QACLO,IAAI,EAAE,SAAAA,CAACyC,CAAI;UAAK,OAAAhD,cAAc,CAACgD,CAAC,CAAC;QAAjB,CAAiB;QACjC5C,KAAK,EAAE,SAAAA,CAAC6C,CAAQ;UAAK,OAAA7C,KAAK,IAAIA,KAAK,CAAC6C,CAAC,CAAC;QAAjB,CAAiB;QACtC3C,QAAQ,EAAE,SAAAA,CAAA;UAAM,OAAAA,QAAQ,IAAIA,QAAQ,EAAE;QAAtB;OACjB;;IAGH,OAAON,cAAc;EACvB,CAAC;EAEO9E,kBAAA,CAAAmD,SAAA,CAAAL,6BAA6B,GAArC;IACE,IAAMkF,QAAQ,GAAG,IAAI,CAAC9F,YAAY;IAClC,IAAM+F,QAAQ,GAAG,IAAI,CAAC9F,SAAS;IAE/B,OAAO,IAAI9C,OAAO,CAAC;MACjB6I,GAAG,EAAEF,QAAQ;MACbG,GAAG,EAAEF,QAAQ;MACbG,MAAM,EAAE;KACT,CAAC;EACJ,CAAC;EAEOpI,kBAAA,CAAAmD,SAAA,CAAAO,4BAA4B,GAApC;IACE,IAAI,IAAI,CAAC2E,yBAAyB,EAAE;MAClCC,aAAa,CAAC,IAAI,CAACD,yBAAyB,CAAC;MAC7C,IAAI,CAACA,yBAAyB,GAAG,IAAI;;EAEzC,CAAC;EAEOrI,kBAAA,CAAAmD,SAAA,CAAAQ,sBAAsB,GAA9B;IACE,IAAI,IAAI,CAAC4E,mBAAmB,EAAE;MAC5BC,YAAY,CAAC,IAAI,CAACD,mBAAmB,CAAC;MACtC,IAAI,CAACA,mBAAmB,GAAG,IAAI;;EAEjC,CAAC;EAEKvI,kBAAA,CAAAmD,SAAA,CAAAS,wBAAwB,GAAhC;IACE,IAAI,IAAI,CAAC6E,qBAAqB,EAAE;MAC9BD,YAAY,CAAC,IAAI,CAACC,qBAAqB,CAAC;MACxC,IAAI,CAACA,qBAAqB,GAAG,IAAI;;EAErC,CAAC;EAEOzI,kBAAA,CAAAmD,SAAA,CAAAM,sBAAsB,GAA9B;IACE,IAAI,IAAI,CAACiF,mBAAmB,EAAE;MAC5BF,YAAY,CAAC,IAAI,CAACE,mBAAmB,CAAC;MACtC,IAAI,CAACA,mBAAmB,GAAG,IAAI;;EAEnC,CAAC;EAEO1I,kBAAA,CAAAmD,SAAA,CAAAwF,oBAAoB,GAA5B;IAAA,IAAA1C,KAAA;IACE,IAAI,IAAI,CAACxE,iBAAiB,GAAG,CAAC,IAAIwB,MAAM,CAACiD,IAAI,CAAC,IAAI,CAAClE,UAAU,CAAC,CAAC4E,MAAM,KAAK,CAAC,EAAE;MAC3E,IAAI,CAAC8B,mBAAmB,GAAGE,UAAU,CAAC;QACpC,IAAI3F,MAAM,CAACiD,IAAI,CAACD,KAAI,CAACjE,UAAU,CAAC,CAAC4E,MAAM,KAAK,CAAC,EAAE;UAC7CX,KAAI,CAAC1C,KAAK,EAAE;;MAEhB,CAAC,EAAE,IAAI,CAAC9B,iBAAiB,CAAC;;EAE9B,CAAC;EAEOzB,kBAAA,CAAAmD,SAAA,CAAAuE,qBAAqB,GAA7B,UAA8BxH,OAAyB,EAAEwF,OAA+C;IAC9F,IAAAmD,KAAK,GAA+B3I,OAAO,CAAA2I,KAAtC;MAAEC,SAAS,GAAoB5I,OAAO,CAAA4I,SAA3B;MAAEC,aAAa,GAAK7I,OAAO,CAAA6I,aAAZ;IAEvC,IAAI,CAACF,KAAK,EAAE;MACV,MAAM,IAAIhH,KAAK,CAAC,uBAAuB,CAAC;;IAG1C,IAAI,CAAC6D,OAAO,EAAE;MACZ,MAAM,IAAI7D,KAAK,CAAC,0BAA0B,CAAC;;IAG7C,IACI,CAAC,IAAArC,WAAA,CAAAuE,OAAQ,EAAC8E,KAAK,CAAC,IAAI,CAAC,IAAAlJ,iBAAA,CAAAqJ,eAAe,EAACH,KAAK,EAAEE,aAAa,CAAC,IAC1DA,aAAa,IAAI,CAAC,IAAAvJ,WAAA,CAAAuE,OAAQ,EAACgF,aAAa,CAAE,IAC1CD,SAAS,IAAI,CAAC,IAAArJ,WAAA,CAAAsE,OAAQ,EAAC+E,SAAS,CAAE,EACpC;MACA,MAAM,IAAIjH,KAAK,CAAC,+DAA+D,GAC7E,sEAAsE,CAAC;;EAE7E,CAAC;EAEO7B,kBAAA,CAAAmD,SAAA,CAAA8F,YAAY,GAApB,UAAqBC,EAAU,EAAEC,IAAY,EAAEC,OAAY;IACzD,IAAMC,eAAe,GAAGD,OAAO,IAAIA,OAAO,CAACP,KAAK,GAAES,QAAA,CAAAA,QAAA,KAE3CF,OAAO;MACVP,KAAK,EAAE,OAAOO,OAAO,CAACP,KAAK,KAAK,QAAQ,GAAGO,OAAO,CAACP,KAAK,GAAG,IAAAnJ,SAAA,CAAA6J,KAAK,EAACH,OAAO,CAACP,KAAK;IAAC,KAEjFO,OAAO;IAET,OAAO;MACLF,EAAE,EAAAA,EAAA;MACFC,IAAI,EAAAA,IAAA;MACJC,OAAO,EAAEC;KACV;EACH,CAAC;EAGOrJ,kBAAA,CAAAmD,SAAA,CAAA0E,YAAY,GAApB,UAAqB2B,MAAW;IAC9B,IAAIC,KAAK,CAACC,OAAO,CAACF,MAAM,CAAC,EAAE;MACzB,OAAOA,MAAM;;IAKf,IAAIA,MAAM,IAAIA,MAAM,CAACA,MAAM,EAAE;MAC3B,OAAO,IAAI,CAAC3B,YAAY,CAAC2B,MAAM,CAACA,MAAM,CAAC;;IAGzC,IAAIA,MAAM,IAAIA,MAAM,CAACG,OAAO,EAAE;MAC5B,OAAO,CAACH,MAAM,CAAC;;IAGjB,OAAO,CAAC;MACNI,IAAI,EAAE,eAAe;MACrBD,OAAO,EAAE,eAAe;MACxBE,aAAa,EAAEL;KAChB,CAAC;EACJ,CAAC;EAEOxJ,kBAAA,CAAAmD,SAAA,CAAAW,WAAW,GAAnB,UAAoBoF,EAAU,EAAEC,IAAY,EAAEC,OAAY;IACxD,IAAI,CAACU,cAAc,CAAC,IAAI,CAACb,YAAY,CAACC,EAAE,EAAEC,IAAI,EAAEC,OAAO,CAAC,CAAC;EAC3D,CAAC;EAGOpJ,kBAAA,CAAAmD,SAAA,CAAA2G,cAAc,GAAtB,UAAuBH,OAAe;IACpC,QAAQ,IAAI,CAACI,MAAM;MACjB,KAAK,IAAI,CAACnI,MAAM,CAACoI,IAAI;QACnB,IAAIC,iBAAiB,GAAWC,IAAI,CAACC,SAAS,CAACR,OAAO,CAAC;QACvD,IAAI;UACFO,IAAI,CAACE,KAAK,CAACH,iBAAiB,CAAC;SAC9B,CAAC,OAAOlC,CAAC,EAAE;UACV,IAAI,CAACtF,YAAY,CAAC4B,IAAI,CAAC,OAAO,EAAE,IAAIxC,KAAK,CAAC,6CAA2C8H,OAAS,CAAC,CAAC;;QAGlG,IAAI,CAAC/G,MAAM,CAACyH,IAAI,CAACJ,iBAAiB,CAAC;QACnC;MACF,KAAK,IAAI,CAACrI,MAAM,CAAC0I,UAAU;QACzB,IAAI,CAAClI,mBAAmB,CAACiF,IAAI,CAACsC,OAAO,CAAC;QAEtC;MACF;QACE,IAAI,CAAC,IAAI,CAACtH,YAAY,EAAE;UACtB,IAAI,CAACI,YAAY,CAAC4B,IAAI,CAAC,OAAO,EAAE,IAAIxC,KAAK,CAAC,wEAAwE,GAChH,kCAAkC,GAAGqI,IAAI,CAACC,SAAS,CAACR,OAAO,CAAC,CAAC,CAAC;;;EAGxE,CAAC;EAEO3J,kBAAA,CAAAmD,SAAA,CAAAoE,mBAAmB,GAA3B;IACE,OAAOgD,MAAM,CAAC,EAAE,IAAI,CAACtI,eAAe,CAAC;EACvC,CAAC;EAEOjC,kBAAA,CAAAmD,SAAA,CAAAmB,YAAY,GAApB;IAAA,IAAA2B,KAAA;IACE,IAAI,CAAC,IAAI,CAAC/E,SAAS,IAAI,IAAI,CAACqB,OAAO,CAACiI,QAAQ,IAAI,IAAI,CAACpJ,oBAAoB,EAAE;MACzE;;IAGF,IAAI,CAAC,IAAI,CAACiB,YAAY,EAAE;MACtBY,MAAM,CAACiD,IAAI,CAAC,IAAI,CAAClE,UAAU,CAAC,CAACmE,OAAO,CAAC,UAACsE,GAAG;QACvCxE,KAAI,CAAC7D,mBAAmB,CAACiF,IAAI,CAC3BpB,KAAI,CAACgD,YAAY,CAACwB,GAAG,EAAE1K,eAAA,CAAAgE,OAAY,CAAC4D,SAAS,EAAE1B,KAAI,CAACjE,UAAU,CAACyI,GAAG,CAAC,CAACvK,OAAO,CAAC,CAC7E;MACH,CAAC,CAAC;MACF,IAAI,CAACmC,YAAY,GAAG,IAAI;;IAG1B,IAAI,CAACuB,wBAAwB,EAAE;IAE/B,IAAM8G,KAAK,GAAG,IAAI,CAACnI,OAAO,CAACoI,QAAQ,EAAE;IACrC,IAAI,CAAClC,qBAAqB,GAAGG,UAAU,CAAC;MACtC3C,KAAI,CAACjD,OAAO,EAAE;IAChB,CAAC,EAAE0H,KAAK,CAAC;EACX,CAAC;EAEO1K,kBAAA,CAAAmD,SAAA,CAAAyH,wBAAwB,GAAhC;IAAA,IAAA3E,KAAA;IACE,IAAI,CAAC7D,mBAAmB,CAAC+D,OAAO,CAAC,UAACwD,OAAO;MACvC1D,KAAI,CAAC6D,cAAc,CAACH,OAAO,CAAC;IAC9B,CAAC,CAAC;IACF,IAAI,CAACvH,mBAAmB,GAAG,EAAE;EAC/B,CAAC;EAEOpC,kBAAA,CAAAmD,SAAA,CAAA0H,eAAe,GAAvB;IACE,IAAI,IAAI,CAACC,oBAAoB,EAAE;MAC7B,IAAI,CAACA,oBAAoB,GAAG,KAAK;MACjC;;IAGF,IAAI,CAAC,IAAI,CAACzI,YAAY,EAAE;MACtB,IAAI,CAACkB,KAAK,CAAC,KAAK,EAAE,IAAI,CAAC;;EAE3B,CAAC;EAEOvD,kBAAA,CAAAmD,SAAA,CAAA4H,sBAAsB,GAA9B;IAAA,IAAA9E,KAAA;IACE,IAAI,CAACtC,sBAAsB,EAAE;IAG7B,IAAI,CAAC4E,mBAAmB,GAAGK,UAAU,CAAC;MACpC,IAAI3C,KAAI,CAAC8D,MAAM,KAAK9D,KAAI,CAACrE,MAAM,CAACoI,IAAI,EAAE;QACpC/D,KAAI,CAAC5D,YAAY,GAAG,IAAI;QACxB4D,KAAI,CAAC1C,KAAK,CAAC,KAAK,EAAE,IAAI,CAAC;;IAE3B,CAAC,EAAE,IAAI,CAACV,uBAAuB,CAAC8H,QAAQ,EAAE,CAAC;EAC7C,CAAC;EAEO3K,kBAAA,CAAAmD,SAAA,CAAAH,OAAO,GAAf;;IAAA,IAAAiD,KAAA;IACE,IAAI,CAACrD,MAAM,QAAO,CAAAvC,EAAA,OAAI,CAACuB,MAAM,EAAA6C,IAAA,CAAAuC,KAAA,CAAA3G,EAAA,EAAA4G,aAAA,UAAC,IAAI,CAAChH,GAAG,EAAE,IAAI,CAAC6B,WAAW,GAAK,IAAI,CAACH,iBAAiB,YAAC;IAEpF,IAAI,CAACoJ,sBAAsB,EAAE;IAE7B,IAAI,CAACnI,MAAM,CAACqB,MAAM,GAAG;MAAA,OAAA+G,SAAA,CAAA/E,KAAA;;;;;oBACf,IAAI,CAAC8D,MAAM,KAAK,IAAI,CAACnI,MAAM,CAACoI,IAAI,GAAhC;cACF,IAAI,CAACrG,sBAAsB,EAAE;cAC7B,IAAI,CAACrB,YAAY,GAAG,KAAK;cACzB,IAAI,CAACG,YAAY,CAAC4B,IAAI,CAAC,IAAI,CAAChC,YAAY,GAAG,cAAc,GAAG,YAAY,CAAC;;;;cAG5B,WAAM,IAAI,CAAC3B,gBAAgB,EAAE;;cAAlEA,gBAAgB,GAAqBL,EAAA,CAAA4K,IAAA,EAA6B;cAGxE,IAAI,CAACnH,WAAW,CAACtD,SAAS,EAAET,eAAA,CAAAgE,OAAY,CAACmH,mBAAmB,EAAExK,gBAAgB,CAAC;cAC/E,IAAI,CAACkK,wBAAwB,EAAE;;;;cAE/B,IAAI,CAAC9G,WAAW,CAACtD,SAAS,EAAET,eAAA,CAAAgE,OAAY,CAACoH,oBAAoB,EAAEC,OAAK,CAAC;cACrE,IAAI,CAACR,wBAAwB,EAAE;;;;;;;KAGpC;IAED,IAAI,CAAChI,MAAM,CAACsB,OAAO,GAAG;MACpB,IAAI,CAAC+B,KAAI,CAAC3D,YAAY,EAAE;QACtB2D,KAAI,CAAC1C,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC;;IAE5B,CAAC;IAED,IAAI,CAACX,MAAM,CAACuB,OAAO,GAAG,UAACkH,GAAU;MAG/BpF,KAAI,CAACxD,YAAY,CAAC4B,IAAI,CAAC,OAAO,EAAEgH,GAAG,CAAC;IACtC,CAAC;IAED,IAAI,CAACzI,MAAM,CAACwB,SAAS,GAAG,UAAC/D,EAAqB;UAAnBiL,IAAI,GAAAjL,EAAA,CAAAiL,IAAA;MAC7BrF,KAAI,CAACsF,mBAAmB,CAACD,IAAI,CAAC;IAChC,CAAC;EACH,CAAC;EAEOtL,kBAAA,CAAAmD,SAAA,CAAAoI,mBAAmB,GAA3B,UAA4BC,YAAiB;IAC3C,IAAIC,aAAkB;IACtB,IAAI7G,IAAY;IAEhB,IAAI;MACF6G,aAAa,GAAGvB,IAAI,CAACE,KAAK,CAACoB,YAAY,CAAC;MACxC5G,IAAI,GAAG6G,aAAa,CAACvC,EAAE;KACxB,CAAC,OAAOnB,CAAC,EAAE;MACV,MAAM,IAAIlG,KAAK,CAAC,0CAAwC2J,YAAc,CAAC;;IAGzE,IACE,CAAEzL,eAAA,CAAAgE,OAAY,CAAC2H,QAAQ,EACrB3L,eAAA,CAAAgE,OAAY,CAAC4H,YAAY,EACzB5L,eAAA,CAAAgE,OAAY,CAAC6H,SAAS,CACvB,CAACC,OAAO,CAACJ,aAAa,CAACtC,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAACnH,UAAU,CAAC4C,IAAI,CAAC,EAC9D;MACA,IAAI,CAACD,WAAW,CAACC,IAAI,CAAC;MAEtB;;IAGF,QAAQ6G,aAAa,CAACtC,IAAI;MACxB,KAAKpJ,eAAA,CAAAgE,OAAY,CAACoH,oBAAoB;QACpC,IAAI,IAAI,CAAC5K,kBAAkB,EAAE;UAC3B,IAAI,CAACA,kBAAkB,CAACkL,aAAa,CAACrC,OAAO,CAAC;;QAEhD;MAEF,KAAKrJ,eAAA,CAAAgE,OAAY,CAAC+H,kBAAkB;QAClC,IAAI,CAACrJ,YAAY,CAAC4B,IAAI,CAAC,IAAI,CAAChC,YAAY,GAAG,aAAa,GAAG,WAAW,EAAEoJ,aAAa,CAACrC,OAAO,CAAC;QAC9F,IAAI,CAAC/G,YAAY,GAAG,KAAK;QACzB,IAAI,CAACE,OAAO,CAACwJ,KAAK,EAAE;QACpB,IAAI,CAAClJ,uBAAuB,CAACkJ,KAAK,EAAE;QAEpC,IAAI,IAAI,CAACxL,kBAAkB,EAAE;UAC3B,IAAI,CAACA,kBAAkB,EAAE;;QAE3B;MAEF,KAAKR,eAAA,CAAAgE,OAAY,CAAC4H,YAAY;QAC5B,IAAMjG,OAAO,GAAG,IAAI,CAAC1D,UAAU,CAAC4C,IAAI,CAAC,CAACc,OAAO;QAC7C,OAAO,IAAI,CAAC1D,UAAU,CAAC4C,IAAI,CAAC;QAC5Bc,OAAO,CAAC4B,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;QAC9B;MAEF,KAAKvH,eAAA,CAAAgE,OAAY,CAAC6H,SAAS;QACzB,IAAI,CAAC5J,UAAU,CAAC4C,IAAI,CAAC,CAACc,OAAO,CAAC,IAAI,CAACmC,YAAY,CAAC4D,aAAa,CAACrC,OAAO,CAAC,EAAE,IAAI,CAAC;QAC7E,OAAO,IAAI,CAACpH,UAAU,CAAC4C,IAAI,CAAC;QAC5B;MAEF,KAAK7E,eAAA,CAAAgE,OAAY,CAAC2H,QAAQ;QACxB,IAAMM,aAAa,GAAG,CAACP,aAAa,CAACrC,OAAO,CAACI,MAAM,GACjDiC,aAAa,CAACrC,OAAO,GAAEE,QAAA,CAAAA,QAAA,KAAKmC,aAAa,CAACrC,OAAO;UAAEI,MAAM,EAAE,IAAI,CAAC3B,YAAY,CAAC4D,aAAa,CAACrC,OAAO,CAACI,MAAM;QAAC,EAAC;QAC7G,IAAI,CAACxH,UAAU,CAAC4C,IAAI,CAAC,CAACc,OAAO,CAAC,IAAI,EAAEsG,aAAa,CAAC;QAClD;MAEF,KAAKjM,eAAA,CAAAgE,OAAY,CAACkI,yBAAyB;QACzC,IAAMC,OAAO,GAAG,OAAO,IAAI,CAACpB,oBAAoB,KAAK,WAAW;QAChE,IAAI,CAACA,oBAAoB,GAAG,IAAI;QAEhC,IAAIoB,OAAO,EAAE;UACX,IAAI,CAACrB,eAAe,EAAE;;QAGxB,IAAI,IAAI,CAACxC,yBAAyB,EAAE;UAClCC,aAAa,CAAC,IAAI,CAACD,yBAAyB,CAAC;UAC7C,IAAI,CAACwC,eAAe,EAAE;;QAExB,IAAI,CAACxC,yBAAyB,GAAG8D,WAAW,CAAC,IAAI,CAACtB,eAAe,CAACpG,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAACtC,SAAS,CAAC;QAC7F;MAEF;QACE,MAAM,IAAIN,KAAK,CAAC,uBAAuB,CAAC;;EAE9C,CAAC;EAEO7B,kBAAA,CAAAmD,SAAA,CAAAwB,WAAW,GAAnB,UAAoBC,IAAY;IAC9B,IAAI,IAAI,CAAC5C,UAAU,CAAC4C,IAAI,CAAC,EAAE;MACzB,OAAO,IAAI,CAAC5C,UAAU,CAAC4C,IAAI,CAAC;MAC5B,IAAI,CAAC+D,oBAAoB,EAAE;MAC3B,IAAI,CAAC7E,WAAW,CAACc,IAAI,EAAE7E,eAAA,CAAAgE,OAAY,CAACqI,QAAQ,EAAE5L,SAAS,CAAC;;EAE5D,CAAC;EACH,OAAAR,kBAAC;AAAD,CAAC,CAhmBD;AAAaqM,OAAA,CAAArM,kBAAA,GAAAA,kBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}